# seasonal approximation of the thermal tolerance curve derived assuming 
# constant temperature through the year

# I first generate a function for the thermal tolerance curve derived
# assuming constant temperature

################################################################################
# this is a mock-up (i.e., not the real one generated by Ibrahim) of the 
# thermal-sensitive, Mean Parasite Burden function resulting from simulations 
# assuming constant temperature, without seasonality. 

# set of temperatures at which thermal tolerance has been evaluated
temp <- c(15.044, 18.397, 19.571, 20.436, 21.147, 21.981, 23.001,
        24.639, 25.844, 26.431, 27.111, 27.575, 28.131, 30.526)

# MPB at the long term equilibrium for the temperature reported above
mpb <- c(1.659,  14.455, 31.754, 50.474, 67.299, 87.678, 107.583, 
        109.479, 86.73, 71.564, 51.896, 35.545, 18.483,  2.37)

# keep just a single curve
d <- data.frame(temp, mpb)

library(rTPC)
library(nls.multstart)
library(broom)
library(tidyverse)
# fit model

fit <- nls_multstart(mpb~gaussian_1987(temp = temp, rmax, topt, a),
                     data = d,
                     iter = c(4,4,4),
                     start_lower = get_start_vals(d$temp, d$mpb, model_name = 'gaussian_1987') - 10,
                     start_upper = get_start_vals(d$temp, d$mpb, model_name = 'gaussian_1987') + 10,
                     lower = get_lower_lims(d$temp, d$mpb, model_name = 'gaussian_1987'),
                     upper = get_upper_lims(d$temp, d$mpb, model_name = 'gaussian_1987'),
                     supp_errors = 'Y',
                     convergence_count = FALSE)
summary(fit)


################################################################################
# I now define the function the yield the mean parasite burden at a given 
# temperature (lamentably, I am unable to use predict in the correct way :(  ) 

nstsMPB <- function(T){    # T is temperature)  
   # MPB <- predict(intf, newdata = data.frame(T)) # wasn't able to make it work
   MPB <- ifelse(T<12 | T>34, 0, # if it is outside climatic envelop
                 115.51399*exp(-0.5*((T-23.79212)/2.55213)^2))
  return(ifelse(MPB>0, MPB,0))  # set to zero negative values
}

################################################################################
# let's check it works and plot the outcome

nstsMPB(temp)  # this is a test to check that it works
nstsMPB(c(20,25,30))  # this is a test to check that it works

mT <- seq(5, 40, by = 0.1) # sequence of mean annual temperatures
plot(temp, mpb, xlim = c(min(mT), max(mT)), ylim = c(0, max(mpb)+10), xlab = 'Temperature', ylab = "MBP", main = 'Thermal-sensitive mean parasite burden')
points(mT, nstsMPB(mT), type='l', col = 'red', lwd = 3)

################################################################################
# now we assume we can approximate the seasonal mean parasite burden by using
# the thermal response derived under assumption of constant temperature and
# using it to derive the mean parasite burden, month after month, by using the
# mean monthly temperature

tm <- seq(0, 11, by = 1)  # sequence of the 12 months, starting from 0

sv <- -cos(2 * pi * tm/12) # seasonal variation normalized betweebn -1 and 1
epsi <- seq(0, 0.3, by = 0.05) # actual seasonal variation (up to 30%)

# set aside memory for the results, a matrix with as many temperature values as
# in "mT" and as many columns as epsilon values
sesMPB <- matrix(data = NA, nrow = length(mT), ncol = length(epsi))

for (i in (1:length(epsi))) {
  for (j in (1:length(mT))) {
    Tmonth <- mT[j] * (1 + epsi[i] * sv) # sderive the sequence of monthly temperatures
    sesMPB[j, i] <- mean(nstsMPB(Tmonth)) # compute MPB
  }
}

wormPrevalenceSm <- function(M) {
  k <- exp(0.61521*log(M) - 4.844146)
  p  <- 1 - (1+M/k)^(-k)    # fraction of humans with at least 1 parasites 
  return(p)
}

sesMPB <- wormPrevalenceSm(sesMPB)

# I replot the figure a second time as such
matplot(mT, sesMPB, type = 'l', ylim = c(0, max(sesMPB)+.2), main = "Arithmetic mean", xlab = 'Temperature', ylab = "Prevalence", col = seq(2, length(epsi)+1), lty = seq(1, length(epsi)))
legend("topright",legend = epsi, col = seq(2, length(epsi)+1), lty = seq(1, length(epsi)), lwd = 1 , cex = 0.6, y.intersp = 0.2, xpd = TRUE, bty = "n")
text(x = par("usr")[2] - 8,    # Adjust x position
     y = par("usr")[4] -.1,  # Adjust y position (above legend)
     labels = "Seasonality",   # Title text
     cex = 0.8,                # Size of the title text
     font = 2,                 # Bold font
     adj = 0.5)                # Center the title

temp_pre <- nstsMPB(mT)
temp_pre <- wormPrevalenceSm(temp_pre)

points(mT, temp_pre, type='l', col = 'red', lwd = 3) # no seasonality
points(temp, wormPrevalenceSm(mpb)) # the datapoints
#points(mT, sesMPB[,which(epsi == epsi[1])], type='l', col = 'red', lwd = 3) # no seasonality


epsi <- seq(0, 0.3, by = 0.05) # actual seasonal variation (up to 30%)


ta <-  18
tb <-  32
tc <-  40
ei <- 7; (epsi[ei])

sa <- ta * (1 + epsi[ei] * sv)
sb <- tb * (1 + epsi[ei] * sv)
sc <- tc * (1 + epsi[ei] * sv)
mT[which(mT == 18)]

points(sa, tm*max(sesMPB)/max(tm), type='l', col = 'blue', lty = 'dotted', lwd = 2)
points(sa, tm*max(sesMPB)/max(tm), pch = 17, col = 'blue', lwd = 3)
abline(v=ta, col = 'blue', lty = 'dashed')
#############################################

points(sb, tm*max(sesMPB)/max(tm), type='l', col = 'orange', lty = 'dotted', lwd = 2)
points(sb, tm*max(sesMPB)/max(tm), pch = 16, col = 'orange', lwd = 3)
abline(v=tb, col = 'orange', lty = 'dashed')
#############################################

points(sc, tm*max(sesMPB)/max(tm), type='l', col = 'pink', lty = 'dotted', lwd = 2)
points(sc, tm*max(sesMPB)/max(tm), pch = 15, col = 'pink', lwd = 3)
abline(v=tc, col = 'pink', lty = 'dashed')

legend(44,40,legend = c(ta, tb, tc), col = c('blue', 'orange', 'pink'), lty = c('dotted', 'dotted', 'dotted'), lwd = 3 , xpd = T, title = "mean Temp", bty = "n")

#############################################
mean(nstsMPB(sc))
points(tc, sesMPB[which(mT == tc),which(epsi == epsi[ei])], col = 'black', lwd = 3) # no seasonality

################################################################################
# let's now check whether it make more sense to work with the difference between
# temperature in the warmest month and temperature in the coldest month, deltaT 

epsi <- c(0, 2, 4, 6, 8, 10, 12)/2 #  half the annual range

for (i in (1:length(epsi))) {
  for (j in (1:length(mT))) {
    Tmonth <- mT[j] + epsi[i] * sv # sderive the sequence of monthly temperatures
    sesMPB[j, i] <- mean(nstsMPB(Tmonth)) # compute MPB
  }
}

sesMPB <- wormPrevalenceSm(sesMPB)

########################################################
matplot(mT, sesMPB, type = 'l', ylim = c(0, max(sesMPB)+0.1), xlab = 'Temperature', ylab = "Prevalence", col = seq(2, length(epsi)+1), lty = seq(1, length(epsi)), lwd = 2)
legend("topright",legend = epsi, col = seq(2, length(epsi)+1), lty = seq(1, length(epsi)), lwd = 1 , cex = 0.6, y.intersp = 0.2, xpd = TRUE, bty = "n")
text(x = par("usr")[2] - 8,    # Adjust x position
     y = par("usr")[4] -.1,  # Adjust y position (above legend)
     labels = "Seasonality",   # Title text
     cex = 0.8,                # Size of the title text
     font = 2,                 # Bold font
     adj = 0.5)                # Center the title

temp_pre <- nstsMPB(mT)
temp_pre <- wormPrevalenceSm(temp_pre)

points(mT, temp_pre, type='l', col = 'red', lwd = 3) # no seasonality
points(temp, wormPrevalenceSm(mpb)) # the datapoints
points(mT, sesMPB[,which(epsi == epsi[ei])], type='l', col = 'black', lwd = 3) # no seasonality
################################################################################


################################################################################
# another possibility is to work again with relative change in tenmperature
# but instead of compuuting the mean, we compute the geometric mean of 
# mean parasite burden +1 (so, the "zero" do not lead the geo.mean to zero)

# FYI, I tried, but the result is horrible it does not reduce the breadth of
# the climatic envelop, only it squashes the curve to lower values
# I leave it for future memory

# back to the original sinusoidal function
sv <- -cos(2 * pi * tm/12) # seasonal variation normalized betweebn -1 and 1
epsi <- seq(0, 0.3, by = 0.05) # actual seasonal variation (up to 30%)

# set aside memory for the results, a matrix with as many temperature values as
# in "mT" and as many columns as epsilon values
sesMPB <- matrix(data = NA, nrow = length(mT), ncol = length(epsi))

for (i in (1:length(epsi))) {
  for (j in (1:length(mT))) {
    Tmonth <- mT[j] * (1 + epsi[i] * sv) # sderive the sequence of monthly temperatures
    sesMPB[j, i] <- -1 + exp(mean(log(nstsMPB(Tmonth)+1))) # compute geometric mean 
  }
}

sesMPB <- wormPrevalenceSm(sesMPB)
################################################################################
matplot(mT, sesMPB, type = 'l', ylim = c(0, max(sesMPB)+0.1), xlab = 'Temperature', ylab = "Prevalence", col = seq(2, length(epsi)+1), lty = seq(1, length(epsi)), lwd = 2, main = "Geometric mean")
legend("topright",legend = epsi, col = seq(2, length(epsi)+1), lty = seq(1, length(epsi)), lwd = 1 , cex = 0.6, y.intersp = 0.2, xpd = TRUE, bty = "n")
text(x = par("usr")[2] - 8,    # Adjust x position
     y = par("usr")[4] -.1,  # Adjust y position (above legend)
     labels = "Seasonality",   # Title text
     cex = 0.8,                # Size of the title text
     font = 2,                 # Bold font
     adj = 0.5)                # Center the title

temp_pre <- nstsMPB(mT)
temp_pre <- wormPrevalenceSm(temp_pre)

points(mT, temp_pre, type='l', col = 'red', lwd = 3) # no seasonality
points(temp, wormPrevalenceSm(mpb)) # the datapoints
#points(mT, sesMPB[,which(epsi == epsi[ei])], type='l', col = 'black', lwd = 3) # no seasonality
################################################################################

